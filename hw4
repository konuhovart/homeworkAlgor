Какие три операции лежат в основе алгоритма разделяй и властвуй?
Разделение (Divide): Задача разбивается на более мелкие подзадачи.
Властвование (Conquer): Решение каждой из меньших подзадач выполняется рекурсивно. Разделенные подзадачи решаются независимо друг от друга. 
Слияние (Combine): Решения для всех меньших подзадач комбинируются в общее решение исходной задачи.

В чем преимущества и недостатки алгоритма разделяй и властвуй?    преимущества:
Решение сложных задач: Алгоритм позволяет эффективно решать сложные задачи, разделяя их на более простые подзадачи.
Параллельное выполнение: Разделение задачи на независимые подзадачи обеспечивает возможность параллельного выполнения.
Модульность и повторное использование: Алгоритм "разделяй и властвуй" обладает модульной структурой, что позволяет повторно использовать код для решения различных задач. 
недостатки: Дополнительные затраты по времени и памяти: Разделение и объединение подзадач может потребовать дополнительных вычислительных ресурсов.
Ограничения на размер подзадач: В некоторых случаях, когда задача не может быть эффективно разделена на меньшие подзадачи.
Сложность разделения задачи: В некоторых случаях разделение исходной задачи на подзадачи может быть сложным или неочевидным.

Опишите алгоритм бинарного поиска словами или псевдокодом
function binarySearch(array, target):
    left = 0
    right = length(array) - 1

    while left <= right:
        mid = (left + right) / 2

        if array[mid] == target:
            return mid
        else if array[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return -1

Какова сложность бинарного поиска?
Сложность бинарного поиска составляет O(log n), где n - размер отсортированного массива.

Попробуйте написать алгоритм бинарного поиска (мы в классе уже делали реализацию - 
попробуйте написать сами, а после посмотрите одно из решений - решение)


Даны два целых числа x и n, напишите функцию для вычисления x^n
Задачу можно решать рекурсивно x^n = x*x*x*x{n раз} - сложность алгоритма O(n)


Задачу можно оптимизировать и решить за O(log(n)) - идея решения в том чтобы уменьшить количество умножений - идея решения - чистая математика 
Попробуйте расписать несколько вариантов (так проще понять решение): x^4 = (x^2)^2 - то есть можно вызывать рекурсию не на всем числе,
а на квадрате числа (исключение нечетная степень) Если сложно понять решение с оптимизацией - рассмотрим оптимальное решение задачи на занятии


Имея два отсортированных массива размера m и n соответственно, вам нужно найти элемент, который будет находиться на k-й позиции в конечном отсортированном массиве. 
Массив 1 - 100 112 256 349 770 Массив 2 - 72 86 113 119 265 445 892 к = 7 Вывод : 256 
Окончательный отсортированный массив - 72, 86, 100, 112, 113, 119, 256, 265, 349, 445, 770, 892 7-й элемент этого массива равен 256.
Идея решения никак не относится к алгоритму разделяй и властвуй - это лишь подготовительный этап для алгоритмов сортировки. Есть несколько возможных решений


Соединить 2 массива в 1, отсортировать и найти значение на позиции k - сложность решения зависит от алгоритма сортировки


Применить более хитрый метод - объявить 3 переменные i1 (для прохода по первому массиву), i2 (для прохода по второму массиву) и res - счетчик для подсчета текущего элемента,
сравнивать по 1 элементу и если элемент в первом массиве меньше второго, то увеличивать i1, иначе увеличивать i2
